from quants.constraints import *

import numpy as np

from itertools import chain
from collections import defaultdict
from abc import ABCMeta, abstractmethod

"""
First we define the base Quantifier class which implements generative and quantification methods 
then we use this class to define some common natural and general (unnatural) quantifiers.
"""


class Quantifier(metaclass=ABCMeta):
    scene_len = 500  # if changed value must be constant across usage since models use it to set input width
    scene_num = 1000  # this can be changed arbitrarily

    def name(self, **kwargs):
        return "{name}({arguments})".format(
            name=self.__class__.__name__,
            arguments=','.join(["{key}={value}".format(key=key, value=value)
                                for key, value in chain(self.__dict__.items(), kwargs.items())]))

    # scene generative methods

    @staticmethod
    def __generate__(n, s):
        """
        generate n uniform random variables that sum up to s

        :param n: number of random variables to generate
        :param s: sum of those n random variables
        :return: n uniform random variables that sum up to s
        """
        uv = np.hstack([np.zeros([1, 1]), np.sort(np.random.rand(1, n-1), axis=1), np.ones([1, 1])])
        return (np.diff(uv, axis=1) * s).astype(int)

    def generate_scene(self, min_len=0, max_len=scene_len):
        """
        Generate a scene that gives a truth value under the quantifier, using the quantifier constraints
        
        # This could have been left as an abstract method but we actually have a way to generate a
        # prototypical scene without requiring the specific quantifier to define a scene generative
        # method. By default we generate a scene prototype by generating a random scene till it passes
        # the quantifier method.
        
        # NOTE: You should refrain from using this default behavior in general since generating a
        # quantifier matching scene by random might take arbitrary long time depending on the
        # prevalence of its truth value
        #
        # while True:
        #     scene = self.generate_random_scene(min_len, max_len)
        #     if self.quantify(scene):
        #         return scene

        :param min_len: minimal number of scene symbols (apart from the don't care symbols)
        :param max_len: maximal number of scene symbols (apart from the don't care symbols)

        :return: the generated scene (list of symbols)

        """
        assert (0 <= min_len <= max_len <= Quantifier.scene_len), "Illegal scene length limits given"

        counts = defaultdict(int)

        # traverse over the constraints twice to check the constant constraints
        for _ in range(2):
            for symbol in symbols:
                for constraint in self.constraints():
                    if not constraint.comply(counts, symbol):
                        raise ValueError("Incompatible constraints can't generate scene")

        while True:
            # random_counts = self.__generate__(len(symbols) - len(counts.keys()),
            #                                   Quantifier.scene_len - sum(counts.values()))

            for symbol in symbols:
                if symbol not in counts:
                    if all([constraint.comply(counts) for constraint in self.constraints()]):
                        return self.scene(counts)

    def generate_scenes(self, scene_num=scene_num, min_len=0, max_len=scene_len):
        """
        Generate scene_num scenes that gives a truth value under the quantifier,

        :param scene_num: number of scenes to generate
        :param min_len: minimal number of scene symbols (apart from the don't care symbols)
        :param max_len: maximal number of scene symbols (apart from the don't care symbols)

        :return: generated scenes
        """
        assert (0 <= min_len <= max_len <= Quantifier.scene_len), "Illegal scene length limits given"

        scenes = [self.generate_scene(min_len, max_len)
                  for _ in range(scene_num)]
        # sanity check that the quantifier is generated quantifier true scenes
        assert (np.all([self.quantify(scene) for scene in scenes])),\
            "{} == False".format(self.name(scene="Scene generated by quantifier"))

        # concatenate scenes to generate a matrix for training
        scenes = np.concatenate(scenes, axis=0)
        return scenes

    @staticmethod
    def generate_random_scene(min_len=0, max_len=scene_len):
        """
        Generate random scene

        :param min_len: minimal number of scene symbols (apart from the don't care symbols)
        :param max_len: maximal number of scene symbols (apart from the don't care symbols)

        :return: the generated scene (list of symbols)
        """
        assert (0 <= min_len <= max_len <= Quantifier.scene_len), "Illegal scene length limits given"

        return np.random.permutation(
            np.concatenate([np.random.choice(symbols[:3], min_len),
                            np.random.choice(symbols, max_len - min_len),
                            np.array([symbols[3]] * (Quantifier.scene_len - max_len))]))

    @staticmethod
    def generate_random_scenes(scene_num=scene_num, min_len=0, max_len=scene_len):
        """
        generates random scenes

        :param scene_num: number of scenes to generate
        :param min_len: minimal number of scene symbols (apart from the don't care symbols)
        :param max_len: maximal number of scene symbols (apart from the don't care symbols)

        :return: generated scenes
        """
        assert (0 <= min_len <= max_len <= Quantifier.scene_len), "Illegal scene length limits given"

        scenes = np.concatenate([Quantifier.generate_random_scene(min_len, max_len)
                                 for _ in range(scene_num)], axis=0)

        # reshape scenes into [scene_num, scene_len] and transform to one hot encoding is necessary
        scenes = scenes.reshape((scene_num, Quantifier.scene_len))
        return scenes

    @staticmethod
    def scene(counts, min_len=0, max_len=scene_len):
        """
        receives a count dictionary for each symbol and returns a random scene with
        ab count symbols marked 0 representing elements in A and B.
        a_b count symbols marked 1 representing elements in A but not in B.
        b_a count symbols marked 2 representing elements in B but not in A.
        c count symbols for the rest of the scene marked 3 meaning irrelevant (complement) elements
        first the symbols are put in order, generating a scene prototype
        then the prototype is permuted to generate the final scene.
        
        :param counts: the input counts
        :param min_len: minimal number of scene symbols (apart from the don't care symbols)
        :param max_len: maximal number of scene symbols (apart from the don't care symbols)

        :return: the constructed scene
        """
        # parameters sanity check
        assert (0 <= min_len <= max_len <= Quantifier.scene_len), "Illegal scene length limits given"

        assert (all([count >= 0 for count in counts])), "Negative symbol count given"
        # if len(counts.keys()) == len(symbols):
        #     # if all counts accounted for check they sum to scene_len
        assert(sum(counts.values()) == Quantifier.scene_len), "Symbol counts don't add up to scene length"
        # else:
        #     # otherwise, assume all important counts given, fill in missing counts arbitrarily
        #     self.fill(counts, min_len, max_len)

        # generate and return the permuted scene prototype
        prototype = np.concatenate([[int(symbol)] * counts[symbol] 
                                    for symbol in symbols]).astype(int)
        return np.random.permutation(prototype)

    # scene quantification methods

    def quantify(self, scene):
        # evaluate the scene by calling the quantifier with the counts of the different symbols
        return self.quantification(defaultdict(int, zip(*np.unique(scene, return_counts=True))))

    def quantification(self, counts):
        # check that counts are compliant with all the constraints
        return all([constraint.check(counts) for constraint in self.constraints()])

    @abstractmethod
    def constraints(self):
        """
        returns the constraints that limit the quantifier's symbol counts
        this is left abstract since we do not allow unconstrained quantifiers
        """
        pass


class Most(Quantifier):
    def constraints(self):
        # most as are bs means that there are more as that are bs than the as that are not
        return [LinearRangeConstraint(a_b_symbol, ab_symbol)]


class Many(Quantifier):
    def constraints(self):
        # many as are bs means that there are more as that are bs than twice the as that are not
        return [LinearRangeConstraint(a_b_symbol, ab_symbol, 2)]


class Few(Quantifier):
    def constraints(self):
        # few as are bs means that there are less as that are bs than twice the as that are not
        return [LinearRangeConstraint(ab_symbol, a_b_symbol, 2)]


class Only(Quantifier):
    def constraints(self):
        # only as are bs means that there are no bs that are not as (non conservative quantifier)
        return [ConstantConstraint(b_a_symbol, 0)]


class Some(Quantifier):
    def constraints(self):
        # some as are bs means that more as are bs than 0
        return [ConstantRangeConstraint(a_b_symbol, 1)]


class AFew(Quantifier):
    def constraints(self):
        # a few as are bs means that more as are bs than 1
        return [ConstantRangeConstraint(a_b_symbol, 2)]


class No(Quantifier):
    def constraints(self):
        return [ConstantConstraint(ab_symbol, 0),
                ConstantRangeConstraint(None, a_b_symbol, 1)]


class All(Quantifier):
    def constraints(self):
        return [ConstantConstraint(a_b_symbol),
                ConstantRangeConstraint(ab_symbol, 1)]


class The(Quantifier):
    def constraints(self):
        return [ConstantConstraint(ab_symbol, 1),
                ConstantConstraint(a_b_symbol, 0)]


class Both(Quantifier):
    def constraints(self):
        return [ConstantConstraint(ab_symbol, 2),
                ConstantConstraint(a_b_symbol, 0)]


class N(Quantifier):
    def __init__(self, n):
        self.n = n

    def constraints(self):
        return [ConstantRangeConstraint(ab_symbol, self.n)]


class ExactlyN(N):
    def constraints(self):
        return [ConstantConstraint(ab_symbol, self.n)]


class MinMax(Quantifier):
    def __init__(self, mini, maxi):
        assert(mini < maxi)
        self._mini = mini
        self._maxi = maxi

    def constraints(self):
        return [ConstantRangeConstraint(ab_symbol, self._mini),
                ConstantRangeConstraint(ab_symbol, self._maxi, reverse=True)]


class Conjunction(Quantifier, metaclass=ABCMeta):
    def __init__(self, quantifiers):
        self._quantifiers = quantifiers

    def name(self):
        return "{name}({quantifiers})".format(
            name=self.__class__.__name__,
            quantifiers=','.join([quantifier.name() for quantifier in self._quantifiers]))


class Or(Conjunction):
    def quantification(self, counts):
        return any([quantifier.quantification(counts) for quantifier in self._quantifiers])

    def constraints(self):
        return np.random.choice(self._quantifiers).constraints()


class And(Conjunction):
    def quantification(self, counts):
        return all([quantifier.quantification(counts) for quantifier in self._quantifiers])

    def constraints(self):
        return [constraint for quantifier in self._quantifiers for constraint in quantifier.constraints()]


class Operator(Quantifier, metaclass=ABCMeta):
    def __init__(self, quantifier):
        self._quantifier = quantifier

    def name(self):
        return "{name}({quantifier})".format(
            name=self.__class__.__name__,
            quantifier=self._quantifier.name())


class Not(Operator):
    def constraints(self):
        return [constraint.reversed() for constraint in self._quantifier.constrains()]
